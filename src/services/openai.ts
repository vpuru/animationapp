import OpenAI from "openai";

const openaiApiKey = process.env.NEXT_PUBLIC_OPENAI_API_KEY;

if (!openaiApiKey) {
  throw new Error("Missing OPENAI_API_KEY environment variable");
}

// Initialize OpenAI client
export const openai = new OpenAI({
  apiKey: openaiApiKey,
});

// Ghibli-style transformation function
export const transformImageToGhibli = async (imageFile: Blob): Promise<string> => {
  try {
    // Convert blob to base64 for OpenAI API
    const arrayBuffer = await imageFile.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const base64Image = buffer.toString("base64");

    // Call OpenAI API to generate Ghibli-style image
    const response = await openai.images.generate({
      model: "dall-e-3",
      prompt:
        "Transform this image into a beautiful Studio Ghibli animation style. Use soft, dreamy colors with a magical atmosphere. Include the characteristic hand-drawn aesthetic with gentle lighting, whimsical details, and the enchanting quality typical of Miyazaki films. Make it look like a scene from a Ghibli movie with lush backgrounds and ethereal beauty.",
      size: "1024x1024",
      quality: "hd",
      n: 1,
    });

    if (!response.data || response.data.length === 0) {
      throw new Error("No image generated by OpenAI");
    }

    const generatedImageUrl = response.data[0].url;
    if (!generatedImageUrl) {
      throw new Error("No image URL in OpenAI response");
    }

    return generatedImageUrl;
  } catch (error) {
    console.error("OpenAI API error:", error);
    if (error instanceof OpenAI.APIError) {
      throw new Error(`OpenAI API Error: ${error.message}`);
    }
    throw new Error(
      `Failed to transform image: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
};

// Download image from URL (for saving processed images)
export const downloadImageFromUrl = async (imageUrl: string): Promise<Blob> => {
  try {
    const response = await fetch(imageUrl);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const blob = await response.blob();

    // Validate that we got an image
    if (!blob.type.startsWith("image/")) {
      throw new Error("Downloaded file is not an image");
    }

    return blob;
  } catch (error) {
    console.error("Image download error:", error);
    throw new Error(
      `Failed to download image: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
};

// Alternative approach using image edit (if we want to modify an existing image)
export const editImageToGhibli = async (imageFile: Blob): Promise<string> => {
  try {
    // Note: This would require the image edit endpoint which needs a mask
    // For now, we'll use the generate endpoint with a more specific prompt
    // that references the uploaded image style

    const response = await openai.images.generate({
      model: "dall-e-3",
      prompt:
        "Create a Studio Ghibli-style animated version of this scene. Transform it with the characteristic soft, hand-drawn aesthetic of Miyazaki films. Use dreamy colors, magical lighting, and the whimsical, enchanting quality typical of Ghibli animations. Add lush, detailed backgrounds and an ethereal, fairy-tale atmosphere.",
      size: "1024x1024",
      quality: "hd",
      n: 1,
    });

    if (!response.data || response.data.length === 0) {
      throw new Error("No image generated by OpenAI");
    }

    const generatedImageUrl = response.data[0].url;
    if (!generatedImageUrl) {
      throw new Error("No image URL in OpenAI response");
    }

    return generatedImageUrl;
  } catch (error) {
    console.error("OpenAI image edit error:", error);
    if (error instanceof OpenAI.APIError) {
      throw new Error(`OpenAI API Error: ${error.message}`);
    }
    throw new Error(
      `Failed to edit image: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
};

// Get file extension from blob type
export const getFileExtension = (blob: Blob): string => {
  const mimeType = blob.type;
  switch (mimeType) {
    case "image/jpeg":
      return "jpg";
    case "image/png":
      return "png";
    case "image/webp":
      return "webp";
    default:
      return "jpg"; // Default fallback
  }
};
